import {
  JsonRpcProvider,
  toUtf8Bytes,
  HDNodeWallet,
  ZeroAddress,
  keccak256,
} from "ethers";
import { AtlasSdk } from "../src";
import { MockOperationsRelay } from "../src/relay/mock";
import { OperationBuilder, ZeroBytes } from "../src/operation";
import { validateBytes32 } from "../src/utils";
import { chainConfig } from "../src/config";

describe("Atlas SDK main tests", () => {
  const chainId = 11155111;
  const provider = new JsonRpcProvider("https://rpc.sepolia.org/", chainId);
  const opsRelay = new MockOperationsRelay();
  const sdk = new AtlasSdk(provider, chainId, opsRelay);

  const testDAppControl = "0xe9c7bEAF3da67d3FB00708ADAE8ab62e578246d7";
  const testCallConfig = 97520;

  const signer = HDNodeWallet.fromSeed(
    toUtf8Bytes("bad seed used for this test only")
  );

  const userOpParams = {
    from: signer.address,
    to: chainConfig[chainId].contracts.atlas.address,
    value: 0n,
    gas: 100000n,
    maxFeePerGas: 30000000000n,
    deadline: 0n,
    dapp: testDAppControl,
    control: testDAppControl,
    data: "0x83a6992a00000000000000000000000000000000000000000000000000000000000000200000000000000000000000007439e9bb6d8a84dd3a23fe621a30f95403f87fb90000000000000000000000000000000000000000000000000000b5e620f480000000000000000000000000007b79995e5f793a07bc00c21412e50ecae098e7f9000000000000000000000000000000000000000000000000000000e8d4a510000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000000",
  };

  test("newUserOperation without sessionKey generation", async () => {
    let [userOp, callConfig] = await sdk.newUserOperation(userOpParams);

    // Validate callConfig
    expect(callConfig).toBe(testCallConfig);

    // Nonce should have been set
    expect(userOp.getField("nonce").value).toBe(1n);

    // Session key should not have been set
    expect(userOp.getField("sessionKey").value).toBe(ZeroAddress);
  });

  test("newUserOperation with sessionKey generation", async () => {
    let [userOp, callConfig] = await sdk.newUserOperation(userOpParams, true);

    // Validate callConfig
    expect(callConfig).toBe(testCallConfig);

    // Nonce should have been set
    expect(userOp.getField("nonce").value).toBe(1n);

    // Session key should have been set
    expect(userOp.getField("sessionKey").value).not.toBe(ZeroAddress);
  });

  test("setUserOperationNonce", async () => {
    let userOp = OperationBuilder.newUserOperation(userOpParams);

    // Nonce not yet set
    expect(userOp.getField("nonce").value).toBe(0n);

    // Set nonce
    userOp = await sdk.setUserOperationNonce(userOp, testCallConfig);

    // Nonce should have been set
    expect(userOp.getField("nonce").value).toBe(1n);
  });

  test("generateSessionKey", () => {
    let userOp = OperationBuilder.newUserOperation(userOpParams);

    // Session key not yet set
    expect(userOp.getField("sessionKey").value).toBe(ZeroAddress);

    // Generate session key
    userOp = sdk.generateSessionKey(userOp);

    // Session key should have been set
    expect(userOp.getField("sessionKey").value).not.toBe(ZeroAddress);
  });

  test("signUserOperation", async () => {
    let userOp = OperationBuilder.newUserOperation(userOpParams);

    // Signature not yet set
    expect(userOp.getField("signature").value).toBe(ZeroBytes);

    // Sign user operation
    userOp = await sdk.signUserOperation(userOp, signer);

    // Signature should have been set
    expect(userOp.getField("signature").value).not.toBe(ZeroBytes);

    // Validate signature
    expect(() =>
      userOp.validateSignature(chainConfig[chainId].eip712Domain)
    ).not.toThrow();
  });

  test("submitUserOperation with invalid session key", async () => {
    let userOp = OperationBuilder.newUserOperation(userOpParams);

    // Set sessionKey manually (not generated by Atlas)
    userOp.setField("sessionKey", "0x1111111111111111111111111111111111111111");

    // Invalid session key
    expect(
      async () => await sdk.submitUserOperation(userOp, testCallConfig)
    ).rejects.toThrow("Session key not found");
  });

  test("submitUserOperation with invalid hints", async () => {
    let userOp = OperationBuilder.newUserOperation(userOpParams);

    // Invalid hints
    const invalidHints = ["0x01"];
    expect(
      async () =>
        await sdk.submitUserOperation(userOp, testCallConfig, invalidHints)
    ).rejects.toThrow("Invalid hint address: 0x01");
  });

  test("submitUserOperation", async () => {
    let userOp = OperationBuilder.newUserOperation(userOpParams);

    // Submit user operation
    let [userOpHash, solverOps] = await sdk.submitUserOperation(
      userOp,
      testCallConfig
    );

    // Validate userOpHash
    expect(userOpHash).toBe(keccak256(userOp.abiEncode()));

    // Validate solverOps
    expect(solverOps.length).toBeGreaterThan(0);
  });

  test("sortSolverOperations with flag exPostBids", async () => {
    let userOp = OperationBuilder.newUserOperation(userOpParams);
    let [, solverOps] = await sdk.submitUserOperation(userOp, testCallConfig);

    const lengthBefore = solverOps.length;

    // solverOps non-empty
    expect(lengthBefore).toBeGreaterThan(0);

    // Sort solver operations
    solverOps = await sdk.sortSolverOperations(userOp, solverOps, 524288);

    // solverOps untouched
    expect(solverOps.length).toBe(lengthBefore);
  });

  test("sortSolverOperations - 0 ops returned without flag zeroSolvers", async () => {
    let userOp = OperationBuilder.newUserOperation(userOpParams);
    let [, solverOps] = await sdk.submitUserOperation(userOp, testCallConfig);

    // solverOps non-empty
    expect(solverOps.length).toBeGreaterThan(0);

    // Sort solver operations
    expect(async () =>
      sdk.sortSolverOperations(userOp, solverOps, testCallConfig)
    ).rejects.toThrow("No solver operations returned");
  });

  test("sortSolverOperations - 0 ops returned with flag zeroSolvers", async () => {
    let userOp = OperationBuilder.newUserOperation(userOpParams);
    let [, solverOps] = await sdk.submitUserOperation(userOp, testCallConfig);

    // solverOps non-empty
    expect(solverOps.length).toBeGreaterThan(0);

    // Sort solver operations
    solverOps = await sdk.sortSolverOperations(userOp, solverOps, 512);

    // solverOps empty
    expect(solverOps.length).toBe(0);
  });

  test("sortSolverOperations", async () => {
    let userOp = OperationBuilder.newUserOperation(userOpParams);

    // Tweak the user operation so solutions won't get discarded by the sorter
    userOp.setField("gas", 0n);
    userOp.setField("maxFeePerGas", 0n);

    let [, solverOps] = await sdk.submitUserOperation(userOp, testCallConfig);

    // solverOps non-empty
    expect(solverOps.length).toBeGreaterThan(0);

    // Sort solver operations
    solverOps = await sdk.sortSolverOperations(userOp, solverOps, 512);

    // Sorted solverOps non-empty
    expect(solverOps.length).toBeGreaterThan(0);

    // Ensure solverOps are sorted
    let prevBidAmount = 0n;
    for (let i = 0; i < solverOps.length; i++) {
      const bidAmount = solverOps[i].getField("bidAmount").value as bigint;
      if (i === 0) {
        prevBidAmount = bidAmount;
        continue;
      }
      expect(bidAmount).toBeLessThanOrEqual(prevBidAmount);
      prevBidAmount = bidAmount;
    }
  });

  test("createDAppOperation session key not found", async () => {
    let userOp = OperationBuilder.newUserOperation(userOpParams);
    let [, solverOps] = await sdk.submitUserOperation(userOp, testCallConfig);

    // Set sessionKey manually (not generated by Atlas)
    userOp.setField("sessionKey", "0x1111111111111111111111111111111111111111");

    // Invalid session key
    expect(
      async () =>
        await sdk.createDAppOperation(userOp, solverOps, testCallConfig)
    ).rejects.toThrow("Session key not found");
  });

  test("createDAppOperation", async () => {
    let userOp = OperationBuilder.newUserOperation(userOpParams);

    // Generate session key
    userOp = sdk.generateSessionKey(userOp);

    let [, solverOps] = await sdk.submitUserOperation(userOp, testCallConfig);

    // Generate dApp operation
    const dAppOp = await sdk.createDAppOperation(
      userOp,
      solverOps,
      testCallConfig
    );

    // Validate dApp operation
    expect(dAppOp.getField("from").value).toBe(
      userOp.getField("sessionKey").value
    );

    // Validate signature
    expect(() =>
      dAppOp.validateSignature(chainConfig[chainId].eip712Domain)
    ).not.toThrow();
  });

  test("getMetacallCalldata", async () => {
    let userOp = OperationBuilder.newUserOperation(userOpParams);

    // Generate session key
    userOp = sdk.generateSessionKey(userOp);

    let [, solverOps] = await sdk.submitUserOperation(userOp, testCallConfig);

    // Generate dApp operation
    const dAppOp = await sdk.createDAppOperation(
      userOp,
      solverOps,
      testCallConfig
    );

    // Get metacall calldata
    const metacallCalldata = sdk.getMetacallCalldata(userOp, solverOps, dAppOp);

    // Validate metacall calldata's function selector only
    expect(metacallCalldata.slice(0, 10)).toBe("0xda91b284");
  });

  test("submitBundle invalid session key", async () => {
    let userOp = OperationBuilder.newUserOperation(userOpParams);

    // Generate session key
    userOp = sdk.generateSessionKey(userOp);

    let [, solverOps] = await sdk.submitUserOperation(userOp, testCallConfig);

    // Generate dApp operation
    const dAppOp = await sdk.createDAppOperation(
      userOp,
      solverOps,
      testCallConfig
    );

    // Change session key
    userOp.setField("sessionKey", "0x1111111111111111111111111111111111111111");

    // Invalid session key
    expect(
      async () =>
        await sdk.submitBundle(
          userOp,
          solverOps,
          dAppOp,
          keccak256(userOp.abiEncode())
        )
    ).rejects.toThrow(
      "User operation session key does not match dApp operation"
    );
  });

  test("submitBundle", async () => {
    let userOp = OperationBuilder.newUserOperation(userOpParams);

    // Generate session key
    userOp = sdk.generateSessionKey(userOp);

    // Sign user operation
    userOp = await sdk.signUserOperation(userOp, signer);

    let [, solverOps] = await sdk.submitUserOperation(userOp, testCallConfig);

    // Generate dApp operation
    const dAppOp = await sdk.createDAppOperation(
      userOp,
      solverOps,
      testCallConfig
    );

    const atlasTxHash = await sdk.submitBundle(
      userOp,
      solverOps,
      dAppOp,
      keccak256(userOp.abiEncode())
    );

    // Validate atlasTxHash
    expect(validateBytes32(atlasTxHash)).toBe(true);
  });
});
